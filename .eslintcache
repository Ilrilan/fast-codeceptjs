[{"C:\\work\\fast-codeceptjs\\src\\App.jsx":"1","C:\\work\\fast-codeceptjs\\src\\stories\\app.stories.jsx":"2","C:\\work\\fast-codeceptjs\\src\\injects\\browser-methods.js":"3"},{"size":3607,"mtime":1606333224199,"results":"4","hashOfConfig":"5"},{"size":1059,"mtime":1606329760584,"results":"6","hashOfConfig":"5"},{"size":7092,"mtime":1606333323125,"results":"7","hashOfConfig":"5"},{"filePath":"8","messages":"9","errorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":11,"source":null},"1glr6tz",{"filePath":"10","messages":"11","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"12","messages":"13","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"14"},"C:\\work\\fast-codeceptjs\\src\\App.jsx",["15","16","17","18","19","20","21","22","23","24","25"],"C:\\work\\fast-codeceptjs\\src\\stories\\app.stories.jsx",["26","27","28","29","30"],"C:\\work\\fast-codeceptjs\\src\\injects\\browser-methods.js",["31","32"],"const ReactTestUtils = __REACT_TEST_UTILS__\n\nfunction assertElementExists(els, locatorStr) {\n  if (!els || els.length === 0) {\n    throw new Error(`Element ${locatorStr} was not found`)\n  }\n}\n\nfunction $x(xpath) {\n  const iterator = document.evaluate(xpath, document, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE)\n  const array = []\n  let item\n  while ((item = iterator.iterateNext())) {\n    array.push(item)\n  }\n\n  return array\n}\n\nfunction _focus(el) {\n  el.focus()\n  ReactTestUtils.Simulate.focus(el)\n}\n\nfunction _click(el) {\n  ReactTestUtils.Simulate.mouseDown(el)\n  ReactTestUtils.Simulate.click(el)\n  el.click()\n  ReactTestUtils.Simulate.mouseUp(el)\n}\n\nfunction isVisible(elem) {\n  if (!(elem instanceof Element)) {\n    throw Error('DomUtil: elem is not an element.')\n  }\n  const style = getComputedStyle(elem)\n  if (style.display === 'none') {\n    return false\n  }\n  if (style.visibility !== 'visible') {\n    return false\n  }\n  /*if (style.opacity < 0.1) {\n      return false\n    }*/\n  const rect = elem.getBoundingClientRect()\n  if (elem.offsetWidth + elem.offsetHeight + rect.height + rect.width === 0) {\n    return false\n  }\n  const elemCenter = {\n    x: rect.left + elem.offsetWidth / 2,\n    y: rect.top + elem.offsetHeight / 2,\n  }\n  if (elemCenter.x < 0) {\n    return false\n  }\n  if (elemCenter.x > (document.documentElement.clientWidth || window.innerWidth)) {\n    return false\n  }\n  if (elemCenter.y < 0) {\n    return false\n  }\n  if (elemCenter.y > (document.documentElement.clientHeight || window.innerHeight)) {\n    return false\n  }\n  let pointContainer = document.elementFromPoint(elemCenter.x, elemCenter.y)\n  do {\n    if (pointContainer === elem) {\n      return true\n    }\n  } while ((pointContainer = pointContainer.parentNode))\n  return false\n}\n\nasync function waitForScript(func, timeout = 5000, args = []) {\n  return new Promise((resolve, reject) => {\n    let finished = false // Флаг нужен, чтоб после резолва случайно ещё раз не вызвался func\n    const superResolve = () => {\n      finished = true\n      resolve()\n    }\n    const timeoutReject = () => {\n      finished = true\n      reject(new Error('waitForScript: timeout end'))\n    }\n    const t1 = setTimeout(timeoutReject, timeout)\n\n    const checkFn = () => {\n      if (finished) {\n        return\n      }\n      if (func(...args)) {\n        clearTimeout(t1)\n        superResolve()\n      } else {\n        setTimeout(checkFn, 0)\n      }\n    }\n    checkFn()\n  })\n}\n\nasync function waitForFunction(fn, argsOrSec, sec) {\n  let timeout\n  let args\n  if (typeof argsOrSec === 'number') {\n    timeout = argsOrSec * 1000\n    args = []\n  } else {\n    args = argsOrSec || []\n    timeout = (sec || 5) * 1000\n  }\n  await waitForScript(fn, timeout, args)\n}\n\n// eslint-disable-next-line max-params\nasync function fill(xpath, locatorStr, value, doBlur = false, done) {\n  async function macroTask() {\n    await new Promise((resolve) => {\n      setTimeout(resolve, 0)\n      if (window.clock) {\n        const time = Date.now()\n        window.clock.tick(1)\n        // запоминаем время и восстанавливаем его, чтобы не сдвигать значения таймеров Синона\n        window.clock.setSystemTime(time)\n      }\n    })\n  }\n\n  if (typeof doBlur === 'function') {\n    done = doBlur\n    doBlur = false\n  }\n\n  try {\n    const els = await $x(xpath)\n    assertElementExists(els, locatorStr)\n    const el = els[0]\n\n    el.focus()\n    ReactTestUtils.Simulate.focus(el)\n\n    await macroTask()\n\n    el.value = value\n    ReactTestUtils.Simulate.change(el)\n\n    await macroTask()\n\n    if (doBlur) {\n      el.blur()\n      ReactTestUtils.Simulate.blur(el)\n\n      await macroTask()\n    } else {\n      try {\n        const pos = el.value.length\n        el.setSelectionRange(pos, pos)\n\n        await macroTask()\n      } catch (e) {}\n    }\n\n    await macroTask()\n\n    done()\n  } catch (e) {\n    done('ERROR: ' + e.toString())\n  }\n}\n\nasync function waitFocused(xpath, locatorStr, done) {\n  return waitForFunction(() => {\n    const el = $x(xpath)[0]\n    return el && el === document.activeElement\n  })\n    .then(() => done('OK'))\n    .catch(() => {\n      done(`ERROR: Element ${locatorStr} was not focused`)\n    })\n}\n\nasync function waitUnfocused(xpath, locatorStr, done) {\n  return waitForFunction(() => {\n    const el = $x(xpath)[0]\n    return el && el !== document.activeElement\n  })\n    .then(() => done('OK'))\n    .catch(() => {\n      done(`ERROR: Element ${locatorStr} still in focus`)\n    })\n}\n\nasync function waitVisible(xpath, locatorStr, done) {\n  return waitForFunction(() => {\n    const el = $x(xpath)[0]\n    return el && isVisible(el)\n  })\n    .then(() => done('OK'))\n    .catch(() => {\n      done(`ERROR: Element ${locatorStr} was invisible`)\n    })\n}\n\nasync function waitDisabled(xpath, locatorStr, done) {\n  return waitForFunction(() => {\n    const el = $x(xpath)[0]\n    return el && el.disabled\n  })\n    .then(() => done('OK'))\n    .catch(() => {\n      done(`ERROR: Element ${locatorStr} was enabled`)\n    })\n}\n\nasync function waitEnabled(xpath, locatorStr, done) {\n  return waitForFunction(() => {\n    const el = $x(xpath)[0]\n    return el && !el.disabled\n  })\n    .then(() => done('OK'))\n    .catch(() => {\n      done(`ERROR: Element ${locatorStr} was disabled`)\n    })\n}\n\nasync function waitInvisible(xpath, locatorStr, done) {\n  return waitForFunction(() => {\n    const el = $x(xpath)[0]\n    return !el || !isVisible(el)\n  })\n    .then(() => done('OK'))\n    .catch(() => {\n      done(`ERROR: Element ${locatorStr} was visible`)\n    })\n}\n\nasync function click(xpath, locatorStr, done) {\n  try {\n    const els = await $x(xpath)\n    assertElementExists(els, locatorStr)\n    const el = els[0]\n\n    _focus(el)\n    _click(el)\n    done('OK')\n  } catch (e) {\n    done('ERROR: ' + e.toString())\n  }\n}\n\nasync function batchExecute(browserMethods, done) {\n  try {\n    const startAllBatch = performance.now()\n    for (let i = 0; i < browserMethods.length; i++) {\n      const [methodName, ...restArgs] = browserMethods[i]\n      const methodFn = publicMethods[methodName]\n      if (!methodFn) {\n        throw new Error(\n          `Method ${methodName} was not correct! Correct variants are: ${Object.keys(publicMethods).join(', ')}`\n        )\n      }\n      const methodPromise = new Promise((resolve) => {\n        const startTime = performance.now()\n        methodFn(...restArgs, (res) => {\n          const endTime = performance.now()\n          console.log(`method ${methodName} result: ${res} executionTime: ${endTime - startTime}`)\n          resolve(res)\n        })\n      })\n      const res = await methodPromise\n      if (res && res.indexOf('ERROR') !== -1) {\n        done(res)\n      }\n    }\n    console.log(`end batch execute, full time: ${performance.now() - startAllBatch}`)\n    done('OK')\n  } catch (e) {\n    done('ERROR: ' + e.toString())\n  }\n}\n\nconst publicMethods = {\n  fill,\n  waitFocused,\n  waitUnfocused,\n  waitVisible,\n  waitInvisible,\n  waitDisabled,\n  waitEnabled,\n  click,\n  batchExecute,\n}\n\nmodule.exports = publicMethods\n",{"ruleId":"33","severity":1,"message":"34","line":58,"column":14,"nodeType":"35","endLine":58,"endColumn":27,"fix":"36"},{"ruleId":"33","severity":1,"message":"34","line":69,"column":14,"nodeType":"35","endLine":69,"endColumn":28,"fix":"37"},{"ruleId":"33","severity":1,"message":"34","line":84,"column":14,"nodeType":"35","endLine":84,"endColumn":26,"fix":"38"},{"ruleId":"33","severity":1,"message":"34","line":96,"column":14,"nodeType":"35","endLine":96,"endColumn":31,"fix":"39"},{"ruleId":"33","severity":1,"message":"34","line":107,"column":14,"nodeType":"35","endLine":107,"endColumn":33,"fix":"40"},{"ruleId":"33","severity":1,"message":"34","line":116,"column":14,"nodeType":"35","endLine":116,"endColumn":24,"fix":"41"},{"ruleId":"33","severity":1,"message":"34","line":117,"column":14,"nodeType":"35","endLine":117,"endColumn":24,"fix":"42"},{"ruleId":"33","severity":1,"message":"34","line":120,"column":15,"nodeType":"35","endLine":120,"endColumn":35,"fix":"43"},{"ruleId":"33","severity":1,"message":"34","line":125,"column":14,"nodeType":"35","endLine":125,"endColumn":24,"fix":"44"},{"ruleId":"33","severity":1,"message":"34","line":126,"column":14,"nodeType":"35","endLine":126,"endColumn":27,"fix":"45"},{"ruleId":"33","severity":1,"message":"34","line":129,"column":15,"nodeType":"35","endLine":129,"endColumn":34,"fix":"46"},{"ruleId":"47","severity":1,"message":"48","line":6,"column":3,"nodeType":"49","messageId":"50","endLine":6,"endColumn":14},{"ruleId":"51","severity":1,"message":"52","line":10,"column":33,"nodeType":"53","endLine":10,"endColumn":63},{"ruleId":"51","severity":1,"message":"52","line":11,"column":32,"nodeType":"53","endLine":11,"endColumn":62},{"ruleId":"51","severity":1,"message":"52","line":13,"column":5,"nodeType":"53","endLine":18,"endColumn":7},{"ruleId":"51","severity":1,"message":"52","line":21,"column":5,"nodeType":"53","endLine":34,"endColumn":7},{"ruleId":"47","severity":1,"message":"48","line":267,"column":11,"nodeType":"49","messageId":"50","endLine":267,"endColumn":22},{"ruleId":"47","severity":1,"message":"48","line":276,"column":5,"nodeType":"49","messageId":"50","endLine":276,"endColumn":16},"react/jsx-curly-brace-presence","Curly braces are unnecessary here.","JSXExpressionContainer",{"range":"54","text":"55"},{"range":"56","text":"57"},{"range":"58","text":"59"},{"range":"60","text":"61"},{"range":"62","text":"63"},{"range":"64","text":"65"},{"range":"66","text":"67"},{"range":"68","text":"69"},{"range":"70","text":"67"},{"range":"71","text":"72"},{"range":"73","text":"74"},"no-console","Unexpected console statement.","MemberExpression","unexpected","react/react-in-jsx-scope","'React' must be in scope when using JSX","JSXOpeningElement",[1517,1530],"\"firstName\"",[1796,1810],"\"secondName\"",[2198,2210],"\"lastName\"",[2516,2533],"\"passportSerie\"",[2813,2832],"\"passportGivenBy\"",[3095,3105],"\"submit\"",[3119,3129],"\"button\"",[3228,3248],"\"Отправить заявку\"",[3310,3320],[3334,3347],"\"clearForm\"",[3439,3458],"\"Очистить заявку\""]